ref_calib_doe[1,]
dim(ref_sim_tot_var)
ref_sim_tot_var[1,]
ref_sim_tot_var[1,1:5]
ref_sim_tot_var[1:5,]
?ref_sim_tot_var
library(anaval)
?ref_sim_tot_var
plot(test_doe)
data(test_doe)
data("ref_calib_doe")
test_doe = calib_doe(nRun = 2, nCalibCurvesPerRun = 3, nrepCalib = 5, ConcVect = c(0, 50, 100, 125, 150, 175, 200))
expect_equal(test_doe, ref_calib_doe)
test_doe = calib_doe(nRun = 2, nCalibCurvesPerRun = 3, nrepCalib = 5, ConcVect = c(0, 50, 100, 125, 150, 175, 200))
test_doe
ref_sim4 <- norm_lin_dataset_sim(ref_sim_tot_var, intercept = 1, slope = 1, SDrun = 1, SDrep = 1, biais = 10)[, "Response"]
ref_sim4_avg <- mean(linear_link_inv(intercept = 1, slope = 1, as.numeric(ref_sim4)))
ref_sim4 <- norm_lin_dataset_sim(ref_sim_tot_var, intercept = 1, slope = 1, SDrun = 1, SDrep = 1, biais = 10)[, "Response"]
ref_sim4_avg <- mean(linear_link_inv(intercept = 1, slope = 1, as.numeric(ref_sim4)))
ref_sim4_avg
?ref_sim_tot_var
ref_sim4_avg
ref_sim4_avg-10
(ref_sim4_avg-10)/10
library(anaval)
?norm_lin_dataset_sim
?calib_doe
calib_doe(nRun = 3, nCalibCurvesPerRun = 2, nrepCalib = 3,
ConcVect = c(0, 50, 100, 125, 150, 175, 200))
myDOE =calib_doe(nRun = 3, nCalibCurvesPerRun = 2, nrepCalib = 3,
ConcVect = c(0, 50, 100, 125, 150, 175, 200))
?norm_lin_dataset_sim
myCalibData = norm_lin_dataset_sim(MyDOE, intercept = 0, slope = 1, SDrun = 10,
SDrep = 10, biais = 0)
myCalibData = norm_lin_dataset_sim(myDOE, intercept = 0, slope = 1, SDrun = 10,
SDrep = 10, biais = 0)
myCalibData
?calib_coef
?calib_coef
library(anaval)
?calib_coef
?calib_coef
?anava::calib_coef
?anaval::calib_coef
calib_coef
?calib_coef
devtools::load_all(".")
?linear_link
?calib_coef
?calib_doe
?calib_doe
?CalibFixedCoefEst
?CalibFixedCoefEst
?calib_coef
library(anaval)
?calib_doe
?calib_coef
?calib_coef
library(anaval)
?calib_coef
library(anaval)
?calib_coef
?calib_doe
library(anaval)
library(anaval)
?calib_doe
library(anaval)
?calib_coef
??calib_coef
devtools::session_info()
install.packages("roxygen2")
devtools::session_info()
library('roxygen2')
devtools::document()
devtools::document()
?calib_coef
RespCalib = calib_coef(DS = myCalibData,LowerRange=0,UpperRange=200,MyModel='lm', diagnostics='TRUE')
myDOE =calib_doe(nRun = 3, nCalibCurvesPerRun = 2, nrepCalib = 3,
ConcVect = c(0, 50, 100, 125, 150, 175, 200))
myCalibData = norm_lin_dataset_sim(myDOE, intercept = 0, slope = 1, SDrun = 10,
SDrep = 10, biais = 0)
RespCalib = calib_coef(DS = myCalibData,LowerRange=0,UpperRange=200,MyModel='lm', diagnostics='TRUE')
RespCalib
devtools::use_data(myCalibData,calib_data)
calib_data = norm_lin_dataset_sim(myDOE, intercept = 0, slope = 1, SDrun = 10,
SDrep = 10, biais = 0)
devtools::use_data(myCalibData,calib_data)
myDOE =calib_doe(nRun = 3, nCalibCurvesPerRun = 2, nrepCalib = 3,
ConcVect = c(0, 50, 100, 125, 150, 175, 200))
calib_data = norm_lin_dataset_sim(myDOE, intercept = 0, slope = 1, SDrun = 10,
SDrep = 10, biais = 0)
devtools::use_data(myCalibData,calib_data)
devtools::use_data(calib_data,calib_data)
RespCalib = calib_coef(DS = calib_data,LowerRange=0,UpperRange=200,MyModel='lm', diagnostics='TRUE')
RespCalib
devtools::document()
calib_data
dim(calib_data)
calib_data[1,]
devtools::document()
str(RespCalib)
RespCalib$FixedEffectEst
RespCalib$FixedEffectEst$estInt
RespCalib$FixedEffectEst['estInt']
mySlope = RespCalib$FixedEffectEst['estSlope']
myIntercept = RespCalib$FixedEffectEst['estInt']
calib_data = norm_lin_dataset_sim(myDOE, intercept = 0, slope = 1, SDrun = 0.5,
SDrep = 0.5, biais = 0)
devtools::use_data(calib_data,calib_data)
devtools::use_data(calib_data,calib_data, overwrite = TRUE)
data("calib_data")
RespCalib = calib_coef(DS = calib_data,LowerRange=0,UpperRange=200,MyModel='lm', diagnostics='TRUE')
myIntercept = RespCalib$FixedEffectEst['estInt']
myIntercept
myDOE =calib_doe(nRun = 6, nCalibCurvesPerRun = 6, nrepCalib = 6,
ConcVect = c(0, 50, 100, 125, 150, 175, 200))
calib_data = norm_lin_dataset_sim(myDOE, intercept = 0, slope = 1, SDrun = 0.5,
SDrep = 0.5, biais = 0)
devtools::use_data(calib_data,calib_data, overwrite = TRUE)
data("calib_data")
RespCalib = calib_coef(DS = calib_data,LowerRange=0,UpperRange=200,MyModel='lm', diagnostics='TRUE')
myIntercept = RespCalib$FixedEffectEst['estInt']
myIntercept
myDOE =calib_doe(nRun = 6, nCalibCurvesPerRun = 6, nrepCalib = 6,
ConcVect = c(0, 50, 100, 125, 150, 175, 200))
calib_data = norm_lin_dataset_sim(myDOE, intercept = 0, slope = 1, SDrun = 0.3,
SDrep = 0.3, biais = 0)
devtools::use_data(calib_data,calib_data, overwrite = TRUE)
data(calib_data)
dim(calib_data)
library(anaval)
data("calib_data")
RespCalib = calib_coef(DS = calib_data,LowerRange=0,UpperRange=200,MyModel='lm', diagnostics='TRUE')
RespCalib
myIntercept
abs(myIntercept - 0)/myIntercept
mySlope
devtools::document()
devtools::document()
?lm
devtools::document()
?anova
devtools::document()
?skewness
?moments
moments::kurtosis
install.packages('moments')
?plot
?qqnorm
data(calib_data)
RespCalib = calib_coef(DS = calib_data,LowerRange=0,UpperRange=200,MyModel='lm')
str(RespCalib)
dim(PredResid)
type(RespCalib$PredResid)
class(RespCalib$PredResid)
RespCalib$PredResid
RespCalib$PredResid[1,]
dim(RespCalib$PredResid)
dim(RespCalib$LOFpValVect)
RespCalib$LOFpValVect
class(RespCalib$LOFpValVect)
data(calib_data)
RespCalib = calib_coef(DS = calib_data,LowerRange=0,UpperRange=200,MyModel='lm')
calib_diagnostics(RespCalib$PredResid, RespCalib$LOFpValVect)
calib_diagnostics <- function(PredResid, LOFpValVect) {
graphics::plot(PredResid[, 1], PredResid[, 2], xlab = "Predicted value", ylab = "Pearson residuals")
stats::qqnorm(PredResid[, 2])
skewness = moments::skewness(PredResid[, 2])
kurtosis = moments::kurtosis(PredResid[, 2])
text(2, 0, paste("skewness: ", round(skewness, 2), sep = ""))
text(2, -5, paste("kurtosis: ", round(kurtosis, 2), sep = ""))
boxplot(LOFpValVect, main = "Lack-of-Fit tests", xlab = "Lack-of-Fit tests of all calibration curves",
ylab = "p-value", xlim = c(0, 10), ylim = c(0, 1.1))
text(6, 1.05, paste("p-val < 5% for ", sum(LOFpValVect < 0.05), " cal. curve(s)", sep = ""))
text(6, 0.9, paste("p-val < 5% for ", round(sum(LOFpValVect < 0.05)/length(LOFpValVect) * 100, 0),
" % of the cal. curves", sep = ""))
}
calib_diagnostics(RespCalib$PredResid, RespCalib$LOFpValVect)
devtools::document()
?text
?boxplot
library(anaval)
packrat::snapshot(prompt = FALSE)
install.packages(c("cluster", "codetools", "foreign", "lattice", "Matrix", "mgcv", "nlme", "survival"), lib="C:/Users/nicdubois/Documents/R project/anaval/packrat/lib-R")
install.packages('ggplot2')
install.packages("ggplot2")
install.packages("moments")
?ggplot
?ggplot2::ggplot
?ggplot
library(anaval)
packrat::snapshot(prompt = FALSE)
devtools::document()
library(anaval)
devtools::document()
library(anaval)
detach("package:anaval", unload=TRUE)
devtools::document()
devtools::document()
?stat_smooth
devtools::document()
library(anaval)
devtools::document()
library(anaval)
data(calib_data)
calib_plot(calib_data)
?ggplot2::xlab
library(anaval)
data(calib_data)
calib_plot(calib_data)
Ds=calib_data
Ds2 = as.data.frame(Ds)
Ds2
length(unique(Ds[, "CalibCurve"])) < 15
length(unique(Ds[, "RunTechnician"])) < 15
d <- ggplot2::ggplot(Ds2, ggplot2::aes(x = as.numeric(as.character(Ds2[, "ConcentrationValue"])),
y = as.numeric(as.character(Ds2[,"Response"])), group = RunTechnician,
colour = RunTechnician))
+ ggplot2::xlab("Theoritical Concentration in ppm")
library(anaval)
data(calib_data)
calib_plot(calib_data)
library(anaval)
data(calib_data)
calib_plot(calib_data)
library(anaval)
data(calib_data)
calib_plot(calib_data)
library(anaval)
myDOE =calib_doe(nRun = 2, nCalibCurvesPerRun = 2, nrepCalib = 2, ConcVect = c(0, 50, 100, 125, 150, 175, 200))
myDOE =calib_doe(nRun = 2, nCalibCurvesPerRun = 2, nrepCalib = 2, ConcVect = c(0, 50, 100, 125, 150, 175, 200))
calib_data2 = norm_lin_dataset_sim(myDOE, intercept = 0, slope = 1, SDrun = 0.3, SDrep = 0.3, biais = 0)
calib_plot(calib_data2)
myDOE =calib_doe(nRun = 2, nCalibCurvesPerRun = 2, nrepCalib = 2, ConcVect = c(0, 50, 100, 125, 150, 175, 200))
calib_data2 = norm_lin_dataset_sim(myDOE, intercept = 0, slope = 1, SDrun = 10, SDrep = 0.3, biais = 0)
calib_plot(calib_data2)
myDOE =calib_doe(nRun = 60, nCalibCurvesPerRun = 60, nrepCalib = 3, ConcVect = c(0, 50, 100, 125, 150, 175, 200))
calib_data3 = norm_lin_dataset_sim(myDOE, intercept = 0, slope = 1, SDrun = 0.3, SDrep = 0.3, biais = 0)
calib_plot(calib_data3)
devtools::document()
library(anaval)
devtools::document()
library(anaval)
data(ref_calib_doe)
(ref_calib_doe, GroupVar = 'CalibCurve', GroupVar2 = 'ConcentrationValue')
library(anaval)
display_a_DOE(ref_calib_doe, GroupVar = 'CalibCurve', GroupVar2 = 'ConcentrationValue')
#' Display the layout of the design of experiment of a dataset in a contengency table.
#'
#' @param Ds1 a matrix or a data.frame produced by a DOE generating function or by a generation of simulated observations function.
#' @param GroupVar is a string of character corresponding to a name of categorical variable (i.e. a column) of Ds1.
#' Each level of this variable will be a row of the contengency table.
#' @param GroupVar2 is a string of character corresponding to a name of categorical variable (i.e. a column) of Ds1.
#' Each level of this variable will be a column of the contengency table.
#' @return An output of class 'table' which corresponds to the contengency table of the two selected variables.
#' @examples
#' data(ref_calib_doe)
#' display_a_DOE(ref_calib_doe, GroupVar = 'CalibCurve', GroupVar2 = 'ConcentrationValue')
#' @export
display_a_DOE = function(Ds1, GroupVar = "CalibCurve", GroupVar2 = "ConcentrationValue") {
ListName = dimnames(Ds1)[[2]]
# GroupVar Selection
ColSelect = ListName[ListName == GroupVar]
FactorGroupVar = Ds1[!duplicated(Ds1[, ColSelect]), ColSelect]
GroupVarVector = Ds1[, ColSelect]
# ContVar
ColSelect2 = ListName[ListName == GroupVar2]
FactorGroupVar2 = Ds1[!duplicated(Ds1[, ColSelect2]), ColSelect2]
GroupVarVector2 = as.character(Ds1[, ColSelect2])
ContengencyTable = as.matrix(table(GroupVarVector, GroupVarVector2))
return(ContengencyTable)
}
#' Summarize the dataset through descriptive statistics
#' @param Ds0 matrix or a data.frame
#' @param VarVect a vector with the name(s) of the numerical variable(s) to summerized
#' @param GroupVar (optional) a string of character corresonding a categorical variable that can
#'  be used to apply the summary statistics to a subgroups of observations
#'  of the dataset.
#'  @examples
#'  data(calib_data)
#'  summary_stat(Ds0=calib_data,VarVect=c('MeasuredConcentration'), GroupVar= 'ConcentrationLabel')
#' @export
summary_stat <- function(Ds0, VarVect, GroupVar = "") {
if (GroupVar == "") {
Output <- list()
for (j in 1:length(VarVect)) {
MyVariable = find_column(Ds0, VarVect[j])
MyDataFrame = data.frame(matrix(NaN, ncol = 4, nrow = 1))
names(MyDataFrame) <- c("Count", "Mean", "Sd", "CV")
Count <- sum(table(MyVariable))
Mean <- mean(as.numeric(as.character(MyVariable)))
SD <- sd(as.numeric(as.character(MyVariable)))
CV <- abs(as.numeric(as.character(SD))/as.numeric(as.character(Mean)))
MyDataFrame[1, ] <- c(Count, Mean, SD, CV)
Output[[j]] <- MyDataFrame
}
} else {
GroupVector = find_column(Ds0, NomdeColonne = GroupVar, "Vector")
GroupColumn = find_column(Ds0, NomdeColonne = GroupVar, "ColumnNumber")
ListGroup = unique(GroupVector)
Output <- list()
for (j in 1:length(VarVect)) {
MyVariable = find_column(Ds0, VarVect[j])
MyDataFrame = data.frame(matrix(NaN, ncol = 4, nrow = length(ListGroup)))
row.names(MyDataFrame) <- ListGroup
names(MyDataFrame) <- c("Count", "Mean", "Sd", "CV")
for (i in 1:length(ListGroup)) {
# Selection of the sub data set corresponding to one instance of the group
GroupLeveli <- ListGroup[i]
MyVariable2 = MyVariable[GroupVector == GroupLeveli]
# Count
Count <- sum(table(MyVariable2))
Mean <- mean(as.numeric(as.character(MyVariable2)))
SD <- sd(as.numeric(as.character(MyVariable2)))
CV <- abs(as.numeric(as.character(SD))/as.numeric(as.character(Mean)))
MyDataFrame[i, ] <- c(Count, Mean, SD, CV)
}
Output[[j]] <- MyDataFrame
}
}
names(Output) <- VarVect
return(Output)
}
#' Summarize the dataset through descriptive statistics
#' @param Ds0 matrix or a data.frame
#' @param VarVect a vector with the name(s) of the numerical variable(s) to summerized
#' @param GroupVar (optional) a string of character corresonding a categorical variable that can
#'  be used to apply the summary statistics to a subgroups of observations
#'  of the dataset.
#'  @examples
#'  summary_stat(Ds0=CalibDs,VarVect=c('MeasuredConcentration'), GroupVar= 'ConcentrationLabel')
#' @export
find_column <- function(Ds0, NomdeColonne, Output = "Vector") {
a = dimnames(Ds0)[[2]]
b = 1:length(a)
c = b[a == NomdeColonne]
d = Ds0[, c]
if (Output == "Vector") {
return(d)
} else return(c)
}
data(ref_calib_doe)
display_a_DOE(ref_calib_doe, GroupVar = 'CalibCurve', GroupVar2 = 'ConcentrationValue')
summary_stat(Ds0=calib_data,VarVect=c('MeasuredConcentration'), GroupVar= 'ConcentrationLabel')
factorlist=c('RunTechnician','ConcentrationLabel','ConcentrationValue','ReplicateNumber','Status','Response')
class(factorlist)
?matrix
?paste
?sprintf
#' Generate the design of experiment for validation studies
#'
#' @param nRun is a numirical scalar corresponding to the number of run(s) sessions that is (are) orginised in the design of experiment.
#' @param nreplicates is a numirical scalar corresponding to the number of replicate in the design of experiment.
#' @param ConcVect is a vector of numerical values corresponding to the concentration (or dilution) in the design of experiment.
#' @param Threshold is a numerical scalar corresponding to the detection limit or the decision limit.
#' @param factorlist is a vector of characters corresponding to the name of the columns of the DOE Do not change!
#' @return An output of class 'matrix' which corresponds to the full factorial design of experiment
#' that is run(s) x replicate(s) x concentration level(s).
#' @examples
#' DOE_Run_Repl_Conc((nRun = 3, nreplicates = 2, ConcVect = c(0, 50, 100, 125,150, 175, 200 ), Threshold='NaN',
#'  factorlist=c('RunTechnician','ConcentrationLabel',
#' 'ConcentrationValue','ReplicateNumber','Status','Response'))
#' @export
DOE_Run_Repl_Conc <- function(nRun = 3, nreplicates = 2, ConcVect = c(0, 50, 100, 125,150, 175, 200 ), Threshold='NaN', factorlist=c('RunTechnician','ConcentrationLabel','ConcentrationValue','ReplicateNumber','Status','Response'))
{
nConc = length(ConcVect)          # number of Concentration levels
ReplicateList = c(1:nreplicates)
MyDOE =  matrix(NaN,nrow = nRun * nConc * nreplicates, ncol = length(factorlist))
colnames(MyDOE) = c(factorlist)
RunList = paste('Run',sprintf("%03d",c(1:nRun)), sep='') # 1st factor levels
rowId = 1
for (i in c(1:nRun))
{
for(j in c(1:nConc))
{
for(k in c(1:nreplicates))
{
MyDOE[rowId,'RunTechnician'] = RunList[i]
MyDOE[rowId,'ConcentrationLabel'] = sprintf("%03d",as.numeric(ConcVect[j]))
MyDOE[rowId,'ConcentrationValue'] = ConcVect[j]
MyDOE[rowId,'ReplicateNumber'] = k
if(!(Threshold == 'NaN'))
{
if(as.numeric(MyDOE[rowId,'ConcentrationValue']) > Threshold)
{
MyDOE[rowId,'Status'] = 'Positive'
} else if(as.numeric(MyDOE[rowId,'ConcentrationValue']) <= Threshold) {
MyDOE[rowId,'Status'] = 'Negative'
}
else MyDOE[rowId,'Status'] = 'Error'
}
rowId=rowId+1
}
}
}
return(MyDOE)
}
DOE_Run_Repl_Conc((nRun = 3, nreplicates = 2, ConcVect = c(0, 50, 100, 125,150, 175, 200 ), Threshold='NaN', factorlist=c('RunTechnician','ConcentrationLabel','ConcentrationValue','ReplicateNumber','Status','Response'))
DOE_Run_Repl_Conc(nRun = 3, nreplicates = 2, ConcVect = c(0, 50, 100, 125,150, 175, 200 ), Threshold='NaN', factorlist=c('RunTechnician','ConcentrationLabel','ConcentrationValue','ReplicateNumber','Status','Response'))
resp = DOE_Run_Repl_Conc(nRun = 3, nreplicates = 2, ConcVect = c(0, 50, 100, 125,150, 175, 200 ), Threshold='NaN', factorlist=c('RunTechnician','ConcentrationLabel','ConcentrationValue','ReplicateNumber','Status','Response'))
class(resp )
library(anaval)
devtools::document()
resp = DOE_Run_Repl_Conc(nRun = 3, nreplicates = 2, ConcVect = c(0, 50, 100, 125,150, 175, 200 ),
Threshold='NaN', factorlist=c('RunTechnician','ConcentrationLabel','ConcentrationValue',
'ReplicateNumber','Status','Response'))
dim(resp)
dim(resp)[1]
resp[1,'RunTechnician']
unique(resp[,'RunTechnician'])
unique(resp[,'ConcentrationVal'])
unique(resp[,'ConcentrationValue'])
unique(resp[,'ReplicateNumber'])
ExMatrix = cbind(c(11,12,13),c(21,22,23),c(31,32,33))
ExMatrix
colnames(ExMatrix) <- c('first_col','second_col','third_col')
ExMatrix
find_column(ExMatrix, NomdeColonne='first_col', Output = "Vector")
find_column(ExMatrix, NomdeColonne='second_col', Output = "Other")
devtools::document()
library(anaval)
devtools::document()
monDOE = DOE_Run_Repl_Conc(nRun = 3, nreplicates = 2, ConcVect = c(0, 50, 100, 125,150, 175, 200 ), Threshold='NaN', factorlist=c('RunTechnician','ConcentrationLabel','ConcentrationValue','ReplicateNumber','Status','Response'))
monDOE
TPL <- norm_lin_dataset_sim(MyDOE, intercept = 1, slope = 2, SDrun=1.5, SDrep=3, biais = 0)
TPL <- norm_lin_dataset_sim(MyDOE, intercept = 1, slope = 2, SDrun=1.5, SDrep=3, biais = 0)
TPL <- norm_lin_dataset_sim(monDOE, intercept = 1, slope = 2, SDrun=1.5, SDrep=3, biais = 0)
TPL
devtools::document()
?norm_lin_dataset_sim
devtools::document()
library(anaval)
?norm_lin_dataset_sim
devtools::document()
?norm_lin_dataset_sim
library(anaval)
?norm_lin_dataset_sim
DOE_Run_Repl_Conc(nRun = 3, nreplicates = 2, ConcVect = c(0, 50, 100, 125,150, 175, 200 ),
Threshold='NaN',
factorlist=c('RunTechnician','ConcentrationLabel',
'ConcentrationValue','ReplicateNumber','Status','Response'))
?display_a_DOE
display_a_DOE(TPL)
display_a_DOE(TPL, GroupVar='RunTechnician', GroupVar2 = 'ConcentrationLabel')
?qplot
bivariate_plot <- function(Ds, YResp = 'MeasuredConcentration', YLongName = 'Measured response')
{
# Plot to verify the simulation data
if (length(unique(Ds[,'RunTechnician'])) < 7)
{
p <- ggplot2::qplot(as.numeric(as.character(Ds[,'ConcentrationValue'])),as.numeric(as.character(Ds[,'MeasuredConcentration'])), xlab="Theoritical Concentration (in ppm)", ylab=YLongName, main="Bivariate graph: Response vs Concentration", colour = Ds[,'RunTechnician'] , shape = Ds[,'RunTechnician'])
q <- p + ggplot2::labs(colour='Run', shape='Run')
print(q)
} else if (length(unique(Ds[,'RunTechnician'])) > 6) {
p <- ggplot2::qplot(as.numeric(as.character(Ds[,'ConcentrationValue'])),as.numeric(as.character(Ds[,'MeasuredConcentration'])), xlab="Theoritical Concentration (in ppm)", ylab=YLongName, main="Bivariate graph: Response vs Concentration")
print(p) }
}
bivariate_plot(TPL)
monDOE = DOE_Run_Repl_Conc(nRun = 7, nreplicates = 2, ConcVect = c(0, 50, 100, 125,150, 175, 200 ), Threshold='NaN', factorlist=c('RunTechnician','ConcentrationLabel','ConcentrationValue','ReplicateNumber','Status','Response'))
TPL <- norm_lin_dataset_sim(monDOE, intercept = 1, slope = 2, SDrun=1.5, SDrep=3, biais = 0)
bivariate_plot(TPL)
devtools::document()
library(anaval)
rm(list = setdiff(ls(), lsf.str()))
?sd
Tables<-SummaryStat(Ds0=ValDataSet,VarVect=c('MeasuredConcentration'), GroupVar= 'ConcentrationLabel')
Tables<-SummaryStat(Ds0=TPL,VarVect=c('MeasuredConcentration'), GroupVar= 'ConcentrationLabel')
Tables<-summary_stat(Ds0=TPL,VarVect=c('MeasuredConcentration'), GroupVar= 'ConcentrationLabel')
monDOE = DOE_Run_Repl_Conc(nRun = 3, nreplicates = 2, ConcVect = c(0, 50, 100, 125,150, 175, 200 ), Threshold='NaN', factorlist=c('RunTechnician','ConcentrationLabel','ConcentrationValue','ReplicateNumber','Status','Response'))
TPL <- norm_lin_dataset_sim(monDOE, intercept = 1, slope = 2, SDrun=1.5, SDrep=3, biais = 0)
display_a_DOE(TPL, GroupVar='RunTechnician', GroupVar2 = 'ConcentrationLabel')
Tables<-summary_stat(Ds0=TPL,VarVect=c('MeasuredConcentration'), GroupVar= 'ConcentrationLabel')
Tables
importFrom("stats", "sd")
devtools::importFrom("stats", "sd")
install.packages(c("cluster", "codetools", "foreign", "lattice", "Matrix", "mgcv", "nlme", "survival"), lib="C:/Users/nicdubois/Documents/R project/anaval/packrat/lib-R")
install.packages("stats")
?lm
?stepAIC
install.packages("MASS")
install.packages("lsmeans")
?lsmeans::stepAIC
?MASS::stepAIC
?summary
?lsmeans::summary
?qt
library(anaval)
rm(list = setdiff(ls(), lsf.str()))
packrat::snapshot(prompt = FALSE)
trueness(Ds = TLP, ac=c(-10,10))
library(anaval)
trueness(Ds = TLP, ac=c(-10,10))
library(anaval)
dim(TPL)
monDOE = DOE_Run_Repl_Conc(nRun = 3, nreplicates = 2, ConcVect = c(0, 50, 100, 125,150, 175, 200 ), Threshold='NaN', factorlist=c('RunTechnician','ConcentrationLabel','ConcentrationValue','ReplicateNumber','Status','Response'))
TPL <- norm_lin_dataset_sim(monDOE, intercept = 1, slope = 2, SDrun=1.5, SDrep=3, biais = 0)
display_a_DOE(TPL, GroupVar='RunTechnician', GroupVar2 = 'ConcentrationLabel')
dim(TPL)
TPL[1,]
devtools::document()
?truenness
?trueness
devtools::document()
?trueness
trueness(TPL)
library(anaval)
trueness(TPL)
library(anaval)
devtools::document()
library(anaval)
library(anaval)
trueness(TPL)
